<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>RStudio Github Analysis</title>
    <meta charset="utf-8" />
    <meta name="author" content="Juno Chen, Ian Flores, Rayce Rossum, Richie Zitomer" />
    <meta name="date" content="2019-06-16" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# RStudio Github Analysis
## What the Git is going on here?
### Juno Chen, Ian Flores, Rayce Rossum, Richie Zitomer
### 2019-06-16

---




class: inverse, center, middle

## Our Partner

.pull-left[
### R Studio
![](rstudio-og.png)
]


.pull-right[
### Dr. Greg Wilson
![](gvwilson-tpl-2017-small.jpg)
]

---
background-image: url("http://avante.biz/wp-content/uploads/2017/04/Computer-Science-Wallpapers-001.jpg")
class: inverse, center, middle

# Overview

---
## Background - Git

.pull-left[
The most widely used modern version control system in the world

Designed with **performance**, **security** and **flexibility** in mind...
]

---
## Background - Git

.pull-left[
The most widely used modern version control system in the world

Designed with **performance**, **security** and **flexibility** in mind...

but not **ease of use**.
]

.pull-right[
![xkcd-git](https://imgs.xkcd.com/comics/git.png)
]

---
## Our Partner's Idea

- Get data for a large number of projects from GitHub.

--

- Identify branching and merging patterns using any statistical or machine learning approach on the commit history of the graphs

--

- Select a small set of common subgraphs that account for a large fraction of everyday use.

--

- Build a tool that provides the common subgraphs that account for the most common patterns.

--

- **Profit.** Well, fame. OK, will you settle for having made the world a better place?

.footnote[
Source: [third-bit.com - Greg's Blog](http://third-bit.com/2017/09/30/git-graphs-and-engineering.html)
]

---

## Our Role

To build the tool, we need to understand how people use Git
- What works for workflows
- What is hindering workflows
- **What are those workflows?**
    
We only have **data** to answer one of these questions
- Access to commit history
- This enables us to draw up recommendations for the new tool that RStudio is interested in developing.  

---

## Our Data

![](workflow.png)

---

class: inverse, center, middle
background-image: url("http://avante.biz/wp-content/uploads/2017/04/Computer-Science-Wallpapers-001.jpg")

# Questions

---
class: inverse, center

&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;

## Question 1

### Are there identifiable workflow patterns in the way people use git?

--

## Question 2

### What are common subgraphs that account for a large fraction of everyday use?

---
## Approach to Identifying Workflow Patterns

- Unsupervised Learning

--

- Natural Language Processing

--

![](https://i.kym-cdn.com/photos/images/original/001/260/099/be0.png)

---
## Challenges

- Working with graph data is new and difficult (the algorithm we're using was published in 2018)

--

- We need to convert this data to something we can work with and cluster

--

- Natural Language Processing also has this problem

---

## Graph2Vec Overview

![](d2v-g2v.png)

---
## Are there identifiable workflow patterns?

![](global_clustering.png)

---
## Greather than 10 commits

![](gt_10_commits.png)

---
## Greather than 100 commits

![](gt_100_commits.png)

---

## Are there identifiable workflow patterns?

--

**Yes**

--

Are they useful?

--

**Not really**, they're mostly just git init's...

--

Out of 36.4 million projects

|            | &gt; 1 Commit    | &gt; 1 Author   |
|------------|---------------|--------------|
| # Projects | 19.03 million | 5.19 million |
| % Total    | 52.29%        | 14.27%       |

--

So why don't we only cluster on large projects?

---
## Clustering on 100+ commits

![](blob.png)

---
## How We'll Answer Question 2 - Overview

- Question 2: What are common subgraphs that account for a large fraction of everyday use?

--

- Motif: subgraphs within a network that appear at a much higher frequency than random chance.

--

&lt;div style="text-align: left"&gt;
- Our procedure for finding motif involves sampling a random node in the graph, then performing a breadth-first search on the first k nodes after that and repeating many times to build up a dataset.

--

&lt;div style="text-align: center"&gt;&lt;img src="motif_example.png"&gt;

---
## How We'll Answer Question 2 - Challenges

- It's challenging to associate similar (but not identical) motifs together.

&lt;div style="text-align: center"&gt;&lt;img src="similar_motifs.png"&gt;

--

&lt;div style="text-align: left"&gt;
- Shorter motifs generated from Git graphs are mostly single chains; longer motifs are hard to interpret.

---
## Choosing Motif Length to Analyze

- Given these challenges, what motif length should we study?

&lt;div style="text-align: center"&gt;&lt;img src="mcp_histograms.png"&gt;

--

&lt;div style="text-align: left"&gt;
- Answer: Study motif lengths 5 and 25.
 - Motif length 5 are useful for seeing the smaller patterns visually.
 - Motifs length 25 are the shortest chain length that aren't overwhelmed by single chains.
 
---
## Most Common Git Motifs

&lt;div style="text-align: center"&gt;&lt;img src="motif_5_visual.png"&gt;

---
## Most Common Git Motifs

&lt;div style="text-align: center"&gt;&lt;img src="motif_25_visual.png"&gt;

---

## Key Findings:

- As you can see, many branches that are created aren't merged back in within the next 5 or 25 commits.

 - 42% of motifs length 5 that start with a branch don't contain a single merge. 13% of motifs length 25 that start with a branch don't contain a single merge.

 - There is 1.41x more branches than merges in the dataset overall.


--

&lt;br /&gt;  

- 84.3% of motifs length 5 and 56.1% of motifs length 25 are a single chain (no branching and merging). 

 - Based on this data, many large projects consist of mostly single chains. 

 - Are these projects fundementally different than projects with branching and merging?

---

## How a Project's Graph Complexity is Related to it's Usage of GitHub Features

&lt;div style="text-align: center"&gt;&lt;img src="GH_features_by_complexity.png"&gt;

&lt;div style="text-align: left"&gt;
- GitHub projects with more complex graphs have more issues, pull requests, and code reviews than projects with simpler graphs.

---
## Limitations to answering both questions

- Squashing
- Public (Only things that make it to github)
- GHTorrent data cleanliness and availability

---
## Summary


- Our questions were aimed to understand:
  - Identifiable workflow patterns in the way people use git
  - Common subgraphs that account for a large fraction of everyday use
  
- To do this we:
  - Performed clustering using Graph2Vec and K Means
  - Extracted motifs from the different projects

- Based on the insights extracted from the data we then divided our recommendations in three categories:
  - Confident
  - Tentative
  - Requires further exploration

---

class: inverse, center, middle
background-image: url("http://avante.biz/wp-content/uploads/2017/04/Computer-Science-Wallpapers-001.jpg")

# Recommendations 
---

## Confident Recommendations
- We can see a consistent percentage of language use in big projects between the largest 8 languages in our sample.
  - A new tool should be language agnostic as users tend to follow patterns not guided by languages.

---
## Tentative Recommendations 

- There is a positive correlation between complexity and GitHub feature usage
  - A new tool should direct users to use the documentation features such as issues and PR reviews to maintain a long term structure.

- Branching is 1.41x more prevalent than merging
  - A new tool should consider a mechanism to force users to keep up to date within a certain number of commits.
  
---
## Requires further exploration

- Couldnâ€™t find evidence of the use of Git Flow or other types of pre-established workflows. 
  - An approach looking specifically for this patterns needs to be considered in order to determine if they are prevalent or not.

- Look at the relationship between the number of people contributing to a repository and the complexity that the project takes in the long run.

---
## Next Steps

- Study the causal relationship between GitHub feature usage and graph complexity
- Trace successful and large projects in the embeddings space
- Weight graphs with the time between commits
- Add graph node attributes such as authors within motifs
- Exclude motifs at beginning and end of graph
- Find repos that claim to use pre-established workflows

---
class: inverse, center, middle
background-image: url("http://avante.biz/wp-content/uploads/2017/04/Computer-Science-Wallpapers-001.jpg")

# Acknowledgments

* RStudio - Greg Wilson
    
* UBC-MDS Teaching Team - Tiffany Timbers
 
* All the other Capstones Teams

---
class: inverse, center, middle
background-image: url("http://avante.biz/wp-content/uploads/2017/04/Computer-Science-Wallpapers-001.jpg")

# Questions?
---
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
